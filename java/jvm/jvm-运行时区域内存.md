# 【Jvm】运行时数据区域

内容来自《深入理解Java虚拟机》。

本篇结构：

- 程序计数器
- Java 虚拟机栈
- 本地方法栈
- Java 堆（Java Heap）
- 方法区
- 运行时常量池
- 直接内存

![](../../images/java/jvm/jvm%20内存划分.jpg)

## 一、程序计数器

程序计数器（Program Counter Register） 是一块较小的内存空间，它可以看作是**当前线程所执行的字节码的行号指示器**。

在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

**每条线程都需要有一个独立的的程序计数器，各条线程间计数器互不影响，独立存储。**我们称这类内存区域为”线程私有”。

在 JVM 规范中规定，如果线程执行的是一个 Java 方法，则程序计数器中保存的是当前需要执行的指令的字节码地址；如果线程执行的是 native 方法，则程序计数器中的值是空(undefined)。

此内存区域是唯一一个在Java 虚拟机中没有规定任何内存泄露（OutOfMemoryError）情况的区域，程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变。

## 二、Java 虚拟机栈

**与程序计数器一样，Java 虚拟机栈也是线程私有的。**

虚拟机栈描述的是**Java 方法**执行的内存模型：

> 每个方法在执行的同时会创建一个栈帧（Stack  Frame）用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

程序每执行一个方法，就会分配一个栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java 栈的顶部。这也是为什么在使用递归方法的时候容易导致栈内存溢出的现象了。 

![](../../images/java/jvm/jvm%20栈.jpg)

在虚拟机规范中，对这个区域规定了两种异常情况：

- 如果线程请求的栈深度大于虚拟所允许的深度，将抛出 StackOverflowError；
- 如果虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存，就会跑出 OutOfMemoryError。

### 2.1、局部变量表

用来存储在编译器可知的基本数据类型的变量（8种基本数据类型）、对象引用(reference 类型）。

对于引用类型的变量，存的是指向对象起始地址的引用指针和 returnAddress 类型（方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址）。

**局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。**

### 2.2、操作数栈

一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程，因此可以说，程序中的所有计算过程都是在借助于操作数栈来完成的。

## 三、本地方法栈

本地方法栈和虚拟机方法栈发挥的作用是非常的相似的，他们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法而服务的，本地方法栈是为虚拟机执行 Native 方法而服务的。

在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，有的虚拟机（譬如：Sun HotSpot虚拟机）直接将虚拟机栈和本地方法栈合二为一。

与虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 异常和OutOfMemoryError 异常。

## 四、Java 堆（Java Heap）

**对于大多数应用来说，Java 堆是虚拟机所管理的内存中最大的一块，Java 堆是所有线程所共享的内存区域；在Java虚拟机启动时创建。Java 堆的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都是在这里分配内存。**

此内存区域 的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，在一点在 Java 虚拟规范中描述：所有的对象以及数组实例都要在堆上分配内存，但随着 JIT 编译技术的发展以及逃逸技术逐步成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配在堆上也渐渐的变得不是那么绝对。Java是垃圾收集器管理的主要区域，因此很多时候被称为 “GC” 堆。

从内存回收的角度看，java 堆可分为：新生代（Eden Space、From Survivor Space、To Survivor Space）和老年代。

如果在堆中没有内存完成实例分配并且堆也无法再扩展时将会抛出 OutOfMemoryError。

## 五、方法区

方法区在 JVM 中也是一个非常重要的区域，它与堆一样，**是被线程共享的区域。**

在方法区中，**存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。**

**方法区（method area）**是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而**永久代**是 **Hotspot** 虚拟机特有的概念（HotSpot 虚拟机以永久代来实现方法区，从而 JVM 的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制），是方法区的一种实现，别的 JVM 都没有这个东西。Hotspot 1.7 后也去除了持久代。

JVM 规范规定，当方法无法满足内存分配的需要时将会抛出 OutOfMemoryError。

### 5.1、永久代和方法区的关系

涉及到内存模型时，往往会提到永久代，那么它和方法区又是什么关系呢？

《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的  JVM  上方法区的实现肯定是不同的了。 同时大多数用的 JVM 都是 Sun 公司的 Hotspot。在 Hotspot 上把 GC 分代收集扩展至方法区，或者说使用永久代来实现方法区。

因此，可以得出结论，永久代是 Hotspot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现。其他的虚拟机实现并没有永久带这一说法。在 1.7 之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区，HotSpot 使用 GC分代来实现方法区内存回收，可以使用如下参数来调节方法区的大小：

```
-XX:PermSize
方法区初始大小
-XX:MaxPermSize
方法区最大大小
超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen
```

### 5.2、元空间

对于 Java8， Hotspot 取消了永久代，那么是不是也就没有方法区了呢？当然不是，方法区是一个规范，规范没变，它就一直在。

取代永久代的就是元空间。它和永久代有什么不同的？

- 存储位置不同，**永久代物理是是堆的一部分，和新生代，老年代地址是连续的，而元空间属于本地内存；**
- 存储内容不同，**元空间存储类的元信息**，静态变量和常量池等并入堆中。相当于永久代的数据被分到了堆和元空间中。

## 六、运行时常量池

**运行时常量池是方法区的一部分。**

Class文件除了有类的版本，字段，方法，接口等描述信息之外，还有一项信息是常量池，**用于存放编译期生成的字面量和符号引用**，这部分内容将在类加载之后进入方法区中的运行时常量池中存放。

它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到 JVM 后，对应的运行时常量池就被创建出来。Java 语言并不要求常量只有编译时才能产生，也就是并非预置到 class 文件中常量池的内容才能进入到方法区运行时常量池，运行区间也可以把新的常量放到池中，使用得比较多的是 String 的 intern（）方法。

当常量池无法申请到内存时将会抛出 OutOfMemoryError。

## 七、直接内存

直接内存（Direct Memory）不是Java 虚拟机规范中定义的内存区域。

在 JDK1.4 中新加入的 NIO 类，引入了一种基于通道（Channel）和缓冲区（Buffer）的 I/O 形式，他可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场所显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。

本机直接内存受本机总内存限制。可能导致 OutOfMemoryError。

